/** 
 * Document
 * Page
 * - CPUProcessor
 * - GPUProcessor
 * Camera
 * Demo
 * Main
 * Networks
 */

class Document {
	"""Initiate identifiers"""
	Document();

	"""Returns true if an e-book version of the document is available"""
	bool hasEBook();

	"""Returns true if a page in the document as been flipped"""
	bool hasFlipped(Mat image1, Mat image2);

	"""Store page temporarily"""
	storeFlippedPage(Mat image);

	"""Delete previously stored image"""
	void deleteCache();

	"""If eBook exists, download specified page from ebook"""
	downloadPage();

	"""If eBook exists, download eBook"""
	downloadBook();
}

class Page {
	Document d;

	"""Initiate identifiers"""
	Page();

	"""Displays the image after rotation"""
	void display();

	""""""
	void deskew(Mat img, double angle, Mat &rotated);

	"""Handles phase 1 of image processing - applying morphological operations"""
	int processImage(Mat image);

	"""Extracts text from image and stores as a string"""
	void OCR(Mat img); 

	"""Returns string result of OCR"""
	string OCRToString();
}

class CPUProcessor extends Page {
	"""Displays the image in the specified window"""
	void display(Mat src);

	"""Applies affine transformation the src image contained in a Mat object given the angle of rotation"""
	void rotate(Mat src, Mat &dst, double angle);
	
	"""Stores frames for averaging"""
	bool imageSum(Mat src, int size, vector<Mat> &Tarray);

	"""Returns a Mat object with an image of a different resolution"""
	void resizeImage(Mat src, Mat &dst, int width, int height);	

	"""Calculates and draws lines with hough transform"""
	void calLines(Mat src, Mat &dst, int threshold, unsigned int *nb, int thickness, double &Fangle, double acute);

	""""""
	int computeSkew(const Mat src);

	"""Finds and stores large isolated blobs within an image"""
	void findBlobs(const cv::Mat &binary, std::vector<std::vector<cv::Point2i>> &blobs);

	"""Returns ratio of white content to black"""
	double getWhiteCount(Mat img);

	"""Initiates imfill(image, 'hole')"""
	void cvFillHoles(cv::Mat &input);
}

class GPUProcessor extends Page {
	"""Displays the image in the specified window"""
	void display(GpuMat src);

	"""Applies affine transformation the src image contained in a GpuMat object given the angle of rotation"""
	void rotate(GpuMat src, GpuMat &dst, double angle);
	
	"""Stores frames for averaging"""
	bool imageSum(GpuMat src, int size, vector<GpuMat> &Tarray);		

	"""Returns a GpuMat object with an image of a different resolution"""
	void resizeImage(GpuMat src, GpuMat &dst, int width, int height);

	"""Calculates and draws lines with hough transform"""
	void calLines(GpuMat src, GpuMat &dst, int threshold, unsigned int *nb, int thickness, double &Fangle, double acute);

	""""""
	int computeSkew(GpuMat src);
}

class Camera {
	"""Initiate identifiers"""
	Camera();

	"""Returns a Mat object of a frame captured from webcam and converts to colour space - Corresponds to process_main() in imgpros"""
	Mat getWebCamInput();
	
	"""Returns a Mat object of an image from a file"""
	Mat getImageFileInput();	

	"""Initialise webcam with frame width and height"""
	int initCamera(int width, int height);
}

class Networks {
	"""Set the ACP header with given message"""
	string setHeader(string message);

	"""Create connection and test until one transmission succeeds"""
	createConnection(char* defaultPort);

	"""Receive until peer closes connection"""
	receiveData();

	"""Cleans up and closes connection"""
	closeConnection();
	
	"""Storing the recognized text from page to the database"""
	sendData(string message)
	
	"""To check if the data has been sent or not"""
	bool sendError()
}

class Main {
	
	/* 
	- obtain input
	- process image
	- store image in cache
	- check with prev image if exists if actually flipped
	- send to OCR
	
	- check page flip
	-   if yes, check against prev stored image
	-      if yes, delete prev stored image, repeat steps

	- check for ebook
	-   if exists, download page/book
	-	store in db 
	*/

	// Begin image processing thread
	Camera cam;
	cam.initCamera(640, 360);	

	while(1) {
		// Get input from webcam or image file
		Mat image = cam.getWebCamInput(); 
		// Mat image = cam.getImageFileInput();

		bool isImageInput;

		storeFlippedPage(image);

		// If using CPU
		Page page = new CPUProcessor();
		// Else if using GPU
		Page page = new GPUProcessor();

		Document doc = new Document();
		Networks nwk = new Networks();

		page.resizeImage(cam.image, cam.image, cam.gHeight, cam.gWidth);
		page.processImage(cam.image);
		page.rotate(cam.image, cam.image, 90);
		
		if(doc.hasEBook()) {
			book = doc.downloadEBook();
			nwk.createConnection("5566");
			nwk.sendData(book);
		}

		if(isImageInput == false) {
			if(doc.hasFlipped(cam.image) || sendError()) {
				doc.deleteCache();
				page.OCR(cam.image);
				string text = page.OCRtoString();
				nwk.createConnection("5566");
				nwk.sendData(setHeader(text));
			}
		}		
	}
}
