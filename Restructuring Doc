/** 
 * Document
 * Page
 * - CPUProcessor
 * - GPUProcessor
 * Camera
 * DemoController
 * MainController
 * Networks
 */

class Document {
	"""Initiate identifiers"""
	Document();

	"""Returns true if an e-book version of the document is available"""
	bool hasEBook();

	"""Returns true if a page in the document as been flipped"""
	bool hasFlipped();

	"""Store page temporarily"""
	storeFlippedPage();

	"""If eBook exists, download specified page from ebook"""
	downloadPage();

	"""If eBook exists, download eBook"""
	downloadBook();
}

class Page {
	Document d;

	"""Initiate identifiers"""
	Page();

	"""Displays the image after rotation"""
	void display();

	""""""
	void deskew(Mat img, double angle, Mat &rotated);

	"""Handles phase 1 of image processing - applying morphological operations"""
	int processImage(Mat image);
}

class CPUProcessor extends Page {
	"""Displays the image in the specified window"""
	void display(Mat src);

	"""Applies affine transformation the src image contained in a Mat object given the angle of rotation"""
	void rotate(Mat src, Mat &dst, double angle);
	
	"""Stores frames for averaging"""
	bool imageSum(Mat src, int size, vector<Mat> &Tarray);

	"""Returns a Mat object with an image of a different resolution"""
	void resizeImage(Mat src, Mat &dst, int width, int height);	

	"""Calculates and draws lines with hough transform"""
	void calLines(Mat src, Mat &dst, int threshold, unsigned int *nb, int thickness, double &Fangle, double acute);

	"""""
	int computeSkew(const Mat src);

	"""Finds and stores large isolated blobs within an image"""
	void findBlobs(const cv::Mat &binary, std::vector<std::vector<cv::Point2i>> &blobs);

	"""Returns ratio of white content to black"""
	double getWhiteCount(Mat img);

	"""Initiates imfill(image, 'hole')"""
	void cvFillHoles(cv::Mat &input);
}

class GPUProcessor extends Page {
	"""Displays the image in the specified window"""
	void display(GpuMat src);

	"""Applies affine transformation the src image contained in a GpuMat object given the angle of rotation"""
	void rotate(GpuMat src, GpuMat &dst, double angle);
	
	"""Stores frames for averaging"""
	bool imageSum(GpuMat src, int size, vector<GpuMat> &Tarray);		

	"""Returns a GpuMat object with an image of a different resolution"""
	void resizeImage(GpuMat src, GpuMat &dst, int width, int height);

	"""Calculates and draws lines with hough transform"""
	void calLines(GpuMat src, GpuMat &dst, int threshold, unsigned int *nb, int thickness, double &Fangle, double acute);

	""""""
	int computeSkew(GpuMat src);
}

class Camera {
	"""Initiate identifiers"""
	Camera();

	"""Returns a Mat object of a frame captured from webcam and converts to colour space - Corresponds to process_main() in imgpros"""
	Mat getWebCamInput();
	
	"""Returns a Mat object of an image from a file"""
	Mat getImageFileInput();	

	"""Initialise webcam with frame width and height"""
	int initCamera(int width, int height);
}

class Networks {
	"""Set the ACP header with given message"""
	string setHeader(string message);

	"""Create connection and test until one transmission succeeds"""
	createConnection();

	"""Receive until peer closes connection"""
	receiveData();

	"""Cleans up and closes connection"""
	closeConnection();
}