/** 
 * Document
 * Page
 * - CPUProcessor
 * - GPUProcessor
 * Camera
 * Demo
 * Main
 * Networks
 */

class Document {
	"""Initiate identifiers"""
	Document();

	"""Returns true if an e-book version of the document is available"""
	bool hasEBook();

	"""Returns true if a page in the document as been flipped"""
	bool hasFlipped();

	"""Store page temporarily"""
	storeFlippedPage();

	"""If eBook exists, download specified page from ebook"""
	downloadPage();

	"""If eBook exists, download eBook"""
	downloadBook();
}

class Page {
	Document d;

	"""Initiate identifiers"""
	Page();

	"""Displays the image after rotation"""
	void display();

	""""""
	void deskew(Mat img, double angle, Mat &rotated);

	"""Handles phase 1 of image processing - applying morphological operations"""
	int processImage(Mat image);

	"""Extracts text from image and stores as a string"""
	void OCR(Mat img); 

	"""Returns string result of OCR"""
	string OCRToString();
}

class CPUProcessor extends Page {
	"""Displays the image in the specified window"""
	void display(Mat src);

	"""Applies affine transformation the src image contained in a Mat object given the angle of rotation"""
	void rotate(Mat src, Mat &dst, double angle);
	
	"""Stores frames for averaging"""
	bool imageSum(Mat src, int size, vector<Mat> &Tarray);

	"""Returns a Mat object with an image of a different resolution"""
	void resizeImage(Mat src, Mat &dst, int width, int height);	

	"""Calculates and draws lines with hough transform"""
	void calLines(Mat src, Mat &dst, int threshold, unsigned int *nb, int thickness, double &Fangle, double acute);

	"""""
	int computeSkew(const Mat src);

	"""Finds and stores large isolated blobs within an image"""
	void findBlobs(const cv::Mat &binary, std::vector<std::vector<cv::Point2i>> &blobs);

	"""Returns ratio of white content to black"""
	double getWhiteCount(Mat img);

	"""Initiates imfill(image, 'hole')"""
	void cvFillHoles(cv::Mat &input);
}

class GPUProcessor extends Page {
	"""Displays the image in the specified window"""
	void display(GpuMat src);

	"""Applies affine transformation the src image contained in a GpuMat object given the angle of rotation"""
	void rotate(GpuMat src, GpuMat &dst, double angle);
	
	"""Stores frames for averaging"""
	bool imageSum(GpuMat src, int size, vector<GpuMat> &Tarray);		

	"""Returns a GpuMat object with an image of a different resolution"""
	void resizeImage(GpuMat src, GpuMat &dst, int width, int height);

	"""Calculates and draws lines with hough transform"""
	void calLines(GpuMat src, GpuMat &dst, int threshold, unsigned int *nb, int thickness, double &Fangle, double acute);

	""""""
	int computeSkew(GpuMat src);
}

class Camera {
	"""Initiate identifiers"""
	Camera();

	"""Returns a Mat object of a frame captured from webcam and converts to colour space - Corresponds to process_main() in imgpros"""
	Mat getWebCamInput();
	
	"""Returns a Mat object of an image from a file"""
	Mat getImageFileInput();	

	"""Initialise webcam with frame width and height"""
	int initCamera(int width, int height);
}

class Networks {
	"""Set the ACP header with given message"""
	string setHeader(string message);

	"""Create connection and test until one transmission succeeds"""
	createConnection(char* defaultPort);

	"""Receive until peer closes connection"""
	receiveData();

	"""Cleans up and closes connection"""
	closeConnection();
	
	""" storing the recognized text from page to the database """
	sendData(string message)
	
	""" To check if the data has been sent or not"""
	bool sendError()
	
}

class Main {
	// Need to decide how to connect Camera, Page

	// Begin image processing thread
	Camera cam;
	cam.initCamera(640, 360);	

	while(1) {
		Mat image = cam.getWebCamInput(); // may need to store it in a variable of Page class
		Page page = new CPUProcessor();
		Document doc = new Document();
		Networks nwk = new Networks();

		page.resizeImage(cam.image, cam.image, cam.gHeight, cam.gWidth);
		page.processImage(cam.image);
		page.rotate(cam.image, cam.image, 90);
		
		if(doc.hasFlipped(cam.image) || sendError())
		{
			page.OCR(cam.image);
			string text = page.OCRtoString();
			nwk.createConnection("5566");
			nwk.sendData(setHeader(text));
		}
			
	}
	
}
